#!/usr/bin/env python3
"""An example script to show how to use experiment helpers."""
# pylint: disable=too-few-public-methods

import logging
from functools import partial

import experiment_helpers as eh


class CustomConfig(eh.config.BaseConfig):
    """A user config class, will be used below."""

    # Add some user attributes.
    user_message: str = "Hello world!"
    user_number: int = 42


# Experiments are defined as functions.
# =====================================

# The experiment runner gives each function a separate directory, so all of
# them can just create files in the current directory.

def standalone():
    """A simple function without config."""
    with eh.data.open("results.csv", "wb") as file:
        file.write('"Hello!",21'.encode())


# Any function may be used, but there is support for passing configuration
# classes easily. Use the `.with_updates` method to load a config class and
# update it with any updates provided in the `config` parameter.
# For example, to override repository defaults with machine-specific settings.

def withconfig(*, config=None):
    """A simple function with config."""
    config = CustomConfig.with_updates(config)  # Load config and update.
    with eh.data.open("results.csv", "wb") as file:
        file.write(f"{config.user_message},{config.user_number}".encode())


# Functions can be parametrized to run experiments with different parameters.
# We encourage allowing  _only_ named parameters (using the `*` syntax`) to make
# sure it is always clear which experiment parameters are set to what value.
# But this is not a requirement.

# Define a base function that takes some parameters.
def withparam(*, config=None, compress: bool):
    """A simple function with config and a parameter."""
    config = CustomConfig.with_updates(config)  # Load config and update.
    # `data.open` can automatically use gzip
    ending = ".gz" if compress else ""
    with eh.data.open(f"results.csv{ending}", "wb") as file:
        file.write(f"{config.user_message},{config.user_number}".encode())


# Parametrized the function to create concrete experiments using `partial`.
compressed = partial(withparam, compress=True)
uncompressed = partial(withparam, compress=False)


# To keep track of whats happening, simply use the `logging` module.
# The experiment runner will automatically capture all logs, even when using
# multiprocessing. It can also be configured to send the logs to slack.

def echo(*, fail: bool):
    """A function to test logging."""
    logging.critical("This is a critical log.")
    logging.error("This is an error log.")
    logging.warning("This is an warning log.")
    logging.info("This is an info log.")
    logging.debug("This is an debug log.")
    if fail:
        raise RuntimeError()


# Create a group of experiments.
# ==============================

# With all functions defined, we can create a group of experiments.
# This group will automatically be available to the CLI. It is also possible
# to have multipe groups, e.g. one group for downloading data, and one group
# for processing. For each group, experiments are provided as a dictionary
# mapping experiment names to functions.

parametrized_experiments = eh.framework.ParametrizedExperiments(
    "experiments",  # Name of experiment group, also command name for CLI.
    {
        "standalone": standalone,
        "withconfig": withconfig,
        # You can use a directory structure to organize experiments.
        "compression/enabled": compressed,
        "compression/disabled": uncompressed,
        "log/success": partial(echo, fail=False),
        "log/failure": partial(echo, fail=True),
    },
    # In many cases, an experiment-specific config is enough, using the
    # `with_updates` method. But if you need to provide configuration defaults
    # to the running itself, e.g. for the logs generated by the framework,
    # you can provide a config base class here.
    configcls=CustomConfig,
)


# Start the CLI.
# ==============

if __name__ == "__main__":
    eh.framework.experiment_cli()
